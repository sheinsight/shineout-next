# Popover 嵌套场景下关闭顺序不正确的问题修复

## 问题描述

在 Popover 组件嵌套使用场景下，当子 Popover 打开时，点击外部区域会导致关闭顺序不正确。具体表现为：
- 父级 Popover 可能先于子级 Popover 关闭
- 点击子 Popover 可能导致父 Popover 意外关闭
- 嵌套层级较深时，关闭行为不符合预期

## 解决方案

通过重构 popup 的父子关系管理机制，确保正确的关闭顺序：

1. **新增父级管理机制**：在 `popup-context` 中新增 `addParent` 和 `removeParent` 方法，用于管理嵌套 Popover 的父子关系链。

2. **优化绑定时机**：将子组件的绑定时机从 `useEffect` 改为 `useLayoutEffect`，并且只在 `open` 状态为 true 时才进行绑定，避免未打开的 Popover 干扰关闭逻辑。

3. **双向关系维护**：子 Popover 不仅要注册到父级的 chain 中，还要通过 `addParent` 方法向上传递，确保整个嵌套链路的完整性。

## 技术细节

### 关键代码变更

1. **popup-context.ts** 新增接口：
```typescript
const defaultContext = {
  addParent: (_ref: React.MutableRefObject<HTMLElement | null>) => {},
  removeParent: (_ref: React.MutableRefObject<HTMLElement | null>) => {},
  bindChild: (_ref: React.MutableRefObject<HTMLElement | null>) => {},
  removeChild: (_ref: React.MutableRefObject<HTMLElement | null>) => {},
};
```

2. **use-popup.ts** 核心改动：
   - 新增 `handleAddParent` 和 `handleRemoveParent` 方法处理父子关系
   - 修改 `bindChild` 逻辑，在绑定子组件时同时调用 `addParent`
   - 使用 `useLayoutEffect` 替代 `useEffect`，确保 DOM 更新前完成绑定
   - 只在 `open` 状态下进行绑定，避免未打开的 Popover 干扰

### 影响范围

本次修复主要影响使用了 Popover 的组件，包括但不限于：
- Select 组件（移除了多余的 bindChild 属性）
- Cascader 组件（移除了多余的 bindChild 属性）
- TreeSelect 组件（移除了多余的 bindChild 属性）
- Tag 组件（调整了 onClose 相关逻辑）

## 使用示例

修复后，嵌套 Popover 的关闭行为符合预期：

```tsx
<Popover content="父级内容">
  <Button>父级触发器</Button>
  <Popover content="子级内容">
    <Button>子级触发器</Button>
  </Popover>
</Popover>
```

现在点击外部区域时，会按照从内到外的顺序依次关闭 Popover，符合用户的直觉预期。