# DatePicker 组件 3.6.7-beta.6 版本变更详情 (PR #1125)

## 问题描述

修复 `DatePicker` 在设置了和 `format` 格式不相符的 `defaultValue` 后会触发多次 onChange 的问题。

### 问题场景示例

当用户设置了一个与 format 格式不匹配的 defaultValue 时，例如：
- format 为 "YYYY-MM-DD"
- defaultValue 为 "2025-05-26 10:30:00"

组件内部会尝试将 defaultValue 格式化为符合 format 的格式，这个过程会触发多次 onChange 事件，导致以下问题：
1. 性能问题：多次触发 onChange 可能导致不必要的渲染和计算
2. 逻辑问题：如果 onChange 中有副作用（如 API 调用），会被多次执行
3. 用户体验问题：表单验证可能被多次触发

## 代码变更文件

1. `packages/hooks/src/components/use-datepicker/index.ts`
   - 导出新增的格式化工具函数

2. `packages/hooks/src/components/use-datepicker/use-datepicker-format.ts`
   - 将内部函数导出供外部使用
   - 新增 `getFormatValueArr` 统一格式化函数

3. `packages/shineout/src/date-picker/date-picker.tsx`
   - 在组件初始化时对 defaultValue 进行预格式化处理

## 变更代码行

### 1. use-datepicker-format.ts 变更

```diff
- const convertValueToDateArr = (
+ export const convertValueToDateArr = (
  value: DatePickerValueType,
  format: string,
  options: {
    weekStartsOn?: number;
    timeZone?: string;
  },
) => {
  // 函数体保持不变
};

- const getFormat = (format: string | undefined, type: string) => {
+ export const getFormat = (format: string | undefined, type: string) => {
  if (typeof format === 'string') return format;
  // 函数体保持不变
};

+ interface FormatValueType {
+   dateArr: (Date | undefined)[];
+   format: string;
+   fmt?: string;
+   type: 'date' | 'datetime' | 'month' | 'time' | 'week' | 'year' | 'quarter';
+   clearWithUndefined?: boolean;
+   options: {
+     timeZone?: string;
+     weekStartsOn?: number;
+   };
+ }
+ 
+ export const getFormatValueArr = (opts: FormatValueType) => {
+   const { dateArr, format, clearWithUndefined, options, type } = opts;
+   const fmt = getFormat(format, type);
+   return dateArr.map((item) => {
+     if (!item) return clearWithUndefined ? undefined : '';
+     return dateUtil.format(item, fmt, options);
+   });
+ };
```

### 2. index.ts 变更

```diff
- export { default as useDatePickerFormat } from './use-datepicker-format';
+ export {
+   default as useDatePickerFormat,
+   getFormatValueArr,
+   convertValueToDateArr,
+   getFormat,
+ } from './use-datepicker-format';
```

### 3. date-picker.tsx 变更

```diff
+ import { useMemo } from 'react';
+ import { DatePicker, getLocale, useConfig } from '@sheinx/base';
+ import { convertValueToDateArr, getFormat, getFormatValueArr } from '@sheinx/hooks'

export default <Value extends DatePickerValueType = DatePickerValueType>(
  props: DatePickerProps<Value>,
) => {
-  return useFieldCommon(props, BaseDatePicker<Value>);
+  const { locale } = useConfig();
+
+  // datepicker 默认值需要提格式化前处理，否则内部会根据 format 进行格式化并再次触发 onChange，参考 v1 v2 的 value hoc 行为
+  const defaultValue = useMemo(() => {
+    if (props.defaultValue) {
+      const options = {
+        timeZone: props.timeZone,
+        weekStartsOn: Number(getLocale(locale, 'startOfWeek')),
+      }
+      const type = props.type || 'date';
+      const format = getFormat(props.format, type);
+      const dateArr = convertValueToDateArr(props.defaultValue, format, options);
+      const formattedDefaultValue = getFormatValueArr({
+        dateArr,
+        format,
+        type,
+        options
+      });
+
+      return (props.range ? formattedDefaultValue : formattedDefaultValue[0]) as Value;
+    }
+    return props.defaultValue;
+  }, [])
+
+  return useFieldCommon({
+    ...props,
+    defaultValue,
+  }, BaseDatePicker<Value>);
};
```

## 变更前后逻辑差异

### 变更前的逻辑
1. 组件接收 defaultValue 后直接传递给内部逻辑
2. 内部逻辑检测到 defaultValue 格式与 format 不匹配
3. 触发格式化处理，生成新的值
4. 新值与原值不同，触发 onChange
5. 可能存在多次格式化和 onChange 触发的循环

### 变更后的逻辑
1. 组件接收 defaultValue 后，在传递给内部逻辑前进行预格式化
2. 使用 useMemo 缓存格式化后的 defaultValue
3. 确保传递给内部的 defaultValue 已经符合 format 格式
4. 避免内部再次格式化，从而避免多次 onChange

### 关键改进点
1. **预处理机制**：在组件最外层对 defaultValue 进行预格式化，确保内部接收到的值已经是正确格式
2. **工具函数导出**：将原本的内部格式化函数导出，使得外层可以使用相同的格式化逻辑
3. **性能优化**：使用 useMemo 缓存格式化结果，避免每次渲染都重新计算

## 变更对组件上下文的影响

### 对组件内部的影响
1. **数据流更清晰**：defaultValue 的格式化在组件最外层完成，内部逻辑更简单
2. **减少重复计算**：避免了内部多次格式化的情况
3. **保持行为一致性**：参考了 v1、v2 版本的 value HOC 行为，保持版本间的一致性

### 对组件外部的影响
1. **onChange 触发次数正常化**：修复了多次触发的问题，现在只会在真正的值变化时触发
2. **新增导出函数**：外部可以使用 `convertValueToDateArr`、`getFormat`、`getFormatValueArr` 进行日期格式化
3. **向后兼容**：对于已经传入正确格式 defaultValue 的使用场景，行为保持不变

## 风险使用场景

### 代码执行风险
1. **依赖 useMemo 的场景**
   - 风险：如果 locale 配置频繁变化，可能导致 defaultValue 重新计算
   - 影响：极端情况下可能有轻微的性能影响
   - 建议：正常使用场景下 locale 不会频繁变化，风险较低

2. **格式化函数的使用**
   - 风险：新导出的函数如果被错误使用，可能产生意外结果
   - 影响：仅影响主动使用这些函数的场景
   - 建议：函数已有完善的类型定义，正确使用即可

### 交互体验差异
1. **onChange 触发时机**
   - 变更前：设置不匹配的 defaultValue 会立即触发多次 onChange
   - 变更后：不会因为格式问题触发 onChange，只在用户真正交互时触发
   - 影响：如果有代码依赖于"设置 defaultValue 时触发 onChange"的行为，需要调整

2. **表单验证场景**
   - 变更前：可能因多次 onChange 导致验证被多次执行
   - 变更后：验证只在必要时执行
   - 影响：提升了用户体验，减少了不必要的验证提示

### 升级建议
1. **检查 onChange 依赖**：如果业务逻辑依赖于 defaultValue 设置时的 onChange，需要调整实现
2. **格式统一**：建议统一 defaultValue 的格式，与 format 保持一致
3. **测试覆盖**：重点测试设置 defaultValue 的场景，确保行为符合预期

## 总结
此次变更主要解决了 DatePicker 组件在处理格式不匹配的 defaultValue 时多次触发 onChange 的问题。通过在组件外层进行预格式化，确保内部接收到的值已经是正确格式，从而避免了重复的格式化和 onChange 触发。变更保持了向后兼容性，对正常使用场景没有影响，同时提升了组件的性能和用户体验。